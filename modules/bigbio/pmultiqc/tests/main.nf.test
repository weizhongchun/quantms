nextflow_process {

    name "Test Process PMULTIQC"
    script "../main.nf"
    process "PMULTIQC"
    tag "modules"
    tag "modules_bigbio"
    tag "pmultiqc"

    config "./nextflow.config"

    test("Should generate MultiQC report") {

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/LFQ_PXD007683.zip"
            def zipFile = file("test_results.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = file("test_results")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def extractFile = new File(resultsDir, entry.name)
                        extractFile.parentFile.mkdirs()
                        extractFile.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [ id: 'test' ]
                input[1] = file('${resultsDir.getAbsolutePath()}')
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert process.out.report.size() > 0 },
                { assert process.out.report[0][1].toString().endsWith('.html') },
                { assert process.out.data.size() > 0 },
                { assert snapshot(process.out.versions).match("versions") }
            )
        }

        cleanup {
            file("test_results").deleteDir()
        }
    }

    test("Should generate MultiQC report with config") {

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/LFQ_PXD007683.zip"
            def zipFile = file("test_results_config.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = file("test_results_config")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def extractFile = new File(resultsDir, entry.name)
                        extractFile.parentFile.mkdirs()
                        extractFile.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [ id: 'test' ]
                input[1] = file('${resultsDir.getAbsolutePath()}')
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert process.out.report.size() > 0 },
                { assert process.out.report[0][1].toString().endsWith('.html') },
                { assert process.out.data.size() > 0 },
                { assert snapshot(process.out.versions).match("versions_config") }
            )
        }

        cleanup {
            file("test_results_config").deleteDir()
        }
    }

    test("Should generate MultiQC report for DIANN") {
        config "./nextflow.config.diann"

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.diann_results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/PXD063291.zip"
            def zipFile = file("test_diann.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = file("test_diann_results")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def extractFile = new File(resultsDir, entry.name)
                        extractFile.parentFile.mkdirs()
                        extractFile.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [ id: 'DIANN_test' ]
                input[1] = file('${resultsDir.getAbsolutePath()}')
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert process.out.report.size() > 0 },
                { assert process.out.report[0][1].toString().endsWith('.html') },
                { assert process.out.data.size() > 0 },
                { assert snapshot(process.out.versions).match("versions_diann") }
            )
        }

        cleanup {
            file("test_diann_results").deleteDir()
        }
    }

    test("Should generate MultiQC report for quantms") {
        config "./nextflow.config.quantms"

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.quantms_results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/LFQ_PXD007683.zip"
            def zipFile = file("test_quantms.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = file("test_quantms_results")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def extractFile = new File(resultsDir, entry.name)
                        extractFile.parentFile.mkdirs()
                        extractFile.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [ id: 'quantms_test' ]
                input[1] = file('${resultsDir.getAbsolutePath()}')
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert process.out.report.size() > 0 },
                { assert process.out.report[0][1].toString().endsWith('.html') },
                { assert process.out.data.size() > 0 },
                { assert snapshot(process.out.versions).match("versions_quantms") }
            )
            // quantms may generate a database file
            if (process.out.quantmsdb.size() > 0) {
                assert process.out.quantmsdb[0].toString().endsWith('.db')
            }
        }

        cleanup {
            file("test_quantms_results").deleteDir()
        }
    }

    test("Should run stub mode") {

        options "-stub"

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/LFQ_PXD007683.zip"
            def zipFile = file("test_stub.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = file("test_stub_results")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def extractFile = new File(resultsDir, entry.name)
                        extractFile.parentFile.mkdirs()
                        extractFile.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [ id: 'test_sample' ]
                input[1] = file('${resultsDir.getAbsolutePath()}')
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert snapshot(
                    process.out.report.collect { file(it[1]).getName() },
                    process.out.data.collect { file(it).getName() },
                    process.out.versions
                ).match("versions_stub") }
            )
        }

        cleanup {
            file("test_stub_results").deleteDir()
        }
    }
}
